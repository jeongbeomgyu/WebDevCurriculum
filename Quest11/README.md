# Quest 11. RDB의 기초와 ORM

## Introduction

- 이번 퀘스트에서는 데이터베이스를 다루는 방법에 대해 알아보겠습니다.

## Topics

- RDBMS
- MySQL
- ORM
- Hash
  - scrypt

## Resources

- [MySQL 101 – The basics](https://www.globo.tech/learning-center/mysql-101-basics/)
- [Sequelize](https://sequelize.org/)
- [안전한 패스워드 저장](https://d2.naver.com/helloworld/318732)

## Checklist

- RDBMS 테이블의 정규화는 무엇인가요?

RDBMS에서의 정규화는 데이터의 중복을 제거하고, 데이터의 무결성을 유지하기 위해 테이블을 분해하는 과정이다. 이는 데이터를 논리적으로 구조화하여, 데이터베이스의 성능을 향상시키고, 데이터의 일관성을 유지하는 데에 중요한 역할을 한다.

- MySQL 외의 RDB에는 어떤 것들이 있나요?

대규모 데이터베이스 및 기업용 애플리케이션에 적합한 Oracle Database, 윈도우 환경에 많이 사용되는 Miscrosoft SQL Server, 오픈소스 RDBMS로 대규모 데이터베이스 및 웹 애플리케이션에 적합한 PostgreSQL, 모바일 애플리케이션 등에서 많이 사용되는 SQLite, 대규모 기업용 애플리케이션에 적합한 IBM DB2등이 있다.

- Relational Database 외에 다른 DB에는 어떤 것들이 있을까요?

NoSQL, 그래프 데이터베이스, Key-Value 데이터베이스, 컬럼 패밀리 데이터베이스, 객체 데이터베이스 등이 있다.

- RDBMS에서 테이블의 인덱싱은 무엇인가요? 인덱싱을 하면 어떤 점이 다르며, 어떤 식으로 동작하나요?

테이블의 인덱싱은 RDBMS에서 데이터 검색 속도를 높이기 위해 테이블에 대한 색인을 생성한 것으로 테이블의 특정 컬럼 값을 기준으로 테이블에 대한 포인터를 생성하는 것이다. 이렇게 생성된 인덱스를 이용한 인덱싱으로 검색을 하면 검색 속도가 빨라진다. RDBMS에서 테이블의 인덱싱은 B-Tree, Hash, Bitmap등의 알고리즘을 사용하여 동작한다. B-Tree인덱스는 트리 구조로 인덱스를 생성하는데, 루트 노드부터 시작하여 리프노드까지 이동하며, 검색하는 값을 비교하면서 다음 노드로 이동한다. Hasg 인덱스는 키-값 쌍으로 저장하는 데이터베이스에서 주로 사용하는데, 검색할 값을 해시 함수를 통해 해시값으로 변환하고, 해당 해시값이 저장된 버킷에 데잍를 검색한다. Bitmap 인덱스는 대용량 데이터에 대한 검색에 사용되는데, 전체 컬럼을 비트열로 표현하여 인덱스를 생성하고 검색할 값을 비트열로 변환하고, 해당 비트여이 1인 레코드를 검색하는 방식으로 동작한다.

- ORM을 사용하는 것은 사용하지 않는 것에 비해 어떤 장단점을 가지고 있나요?

ORM을 장점은 객체지향 프로그래밍에서 사용하는 클래스, 객체 등을 이용하여 SQL 쿼리문 작성을 대신해주고 객체와 관계형 데이터베이스 간의 매핑을 ORM 프레임워크가 처리하기 때문에, 관계형 데이터베이스의 스키마 변경에 대한 대처가 더욱 편하다. 또한 ORM 프레임워크가 제공하는 다양한 함수와 기능들을 사용할 수 있고, ORM 프레임워크에서 제공하는 보안 기능들을 이용할 수 있다. 단점으로는 ORM 프레임 워크 내부에서 처리되는 작업들은 SQL 쿼리문으로 변환되어 수행되므로, 프레임워크 내부적으로 추가적인 오버헤드가 발생할 수 있고 성능에 관련한 문제가 발생할 수 있다.

- 자바스크립트 생태계의 ORM에는 어떤 것들이 있나요?

node.js에서 사용할 수 있는 ORM인 Sequelize와 Bookshelf, TypeScript로 작성된 ORM인 TypeORM과 Prisma,Waterline,NestJS,LoopBack,Objection,js등이 있다.

- 모델간의 1:1, 1:N, N:M 관계는 각각 무엇이고 어떨 때 사용하나요?

1:1 관계는 한 개의 레코드가 다른 한 개의 레코드와 1:1로 대응하는 관계이다. 주로 두 개의 모델이 서로 강한 연결을 가지고 있으며, 하나의 모델이 다른 모델을 참조할 때 사용된다. 1:N 관계는 한개의 레코드가 다른 여러 개의 레코드와 대응하는 관계이다. 주로 하나의 모델이 다른 모델을 참조하고 있을 때 사용된다. N:M 관계는 여러 개의 레코드가 서로 다른 여러 개의 레코드와 대응하는 관계이다. 주로 두개 모델이 서로 강한 연결을 가지고 있으며, 중간 테이블을 통해 구현된다.

- DB에 사용자의 암호를 평문으로 저장하지 않고도 사용자의 암호를 인증하는 것이 가능한 이유는 무엇일까요?

시스템에서 암호를 해시 함수를 사용하여 암호화하고 해시된 결과를 저장한다. 해시 함수는 입력된 데이터를 고정된 길이의 암호화된 문자열로 변환하고, 같은 입력에 대해서는 항상 같은 출력이 생성되며, 출력된 문자열에서 입력을 복원할 수 없다. 그렇기 때문에 암호를 DB에 저장할 때에는 해시 함수를 사용하여 암호화하고, 인증할 때에는 입력받은 암호를 같은 해시함수로 암호화하여 DB에 저장된 암호와 비교해서 인증한다.

- 해시 함수에는 어떤 것이 있나요?

MD-5, SHA, SHA-3, bcrypt, scrypt가 있다.

- 사용자의 암호를 해싱하여 저장할 때 어떤 식으로 저장하는 것이 보안에 좋을까요?
  사용자 암호와 함께 랜덤한 솔트를 결합해서 해시를 생성하여 해시된 암호가 미리 계산된 암호 해시 테이블에 대조되는 것을 막거나, 안전한 해시 함수를 사용하여 암호를 해시한다. 또한 해시함수를 적용하는 횟수를 늘리거나, HTTPS와 같은 보안 프로토콜을 사용하여 암호를 안전하게 전송한다.

## Quest

- 이번에는 메모장을 파일이 아닌 DB기반으로 만들어 보고자 합니다.
  - 적절한 테이블을 설계해 보세요.
  - Sequelize를 이용하여 데이터의 모델을 만들고 어플리케이션에 적용해 보세요.
  - 사용자의 비밀번호는 해싱을 통해 저장되어야 합니다.

## Advanced

- Object–relational impedance mismatch란 어떤 개념인가요?
- Foreign Key란 무엇인가요? 이것을 사용할 때의 장점과 단점은 무엇일까요?
- 이전에 쓰이던 해시함수들에는 어떤 것이 있을까요? 패스워드 해싱의 추세의 역사는 어떻게 이어져왔나요?
